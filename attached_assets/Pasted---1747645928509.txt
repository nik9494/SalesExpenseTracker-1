Техническое задание для игровой платформы
соедени это все вместе и сделай детальное техническое задание вместе с таблицаи колонками и всем остальным в базы данныхтак же особенно удели внимание разделению разных комнат и их логике и самому интерфейсу что кто и где будет видеть на всех этапах 

просмотри все еще раз и добавь то чего нет 

Техническое задание и описание пользовательского флоу Ниже — свёрнутое, но исчерпывающее описание всех ключевых компонентов системы, а также то, что видит и ощущает пользователь на каждом этапе.

1. Аутентификация и безопасность
1. Регистрация/логин
    * При нажатии «Старт» в боте Telegram серверный webhook извлекает из telegram-web-app.js данные:
        * telegram_id 
        * username, first_name, last_name 
        * photo_url 
        * (опционально) phone_number — если разрешён доступ, иначе пусто. 
    * Если запись с таким telegram_id не найдена в схеме auth.users, создаётся новая запись с копированием полей из public.users. Анонименых записей не хранится. 
    * Проверка и копирование выполняются в рамках одной транзакции: либо всё прошло, либо нет. В случае ошибки попытка повторяется автоматически до трёх раз; при продолжающихся сбоях логируем в Prometheus/Sentry и возвращаем в бота вежливую ошибку. 
    * После успешного создания/нахождения пользователя генерируется JWT (HMAC‑SHA256, секрет из env). Подмена telegram_id невозможна, т.к. токен подписывается серверным секретом и валидируется по входящему telegram_id от клиента. 
2. Row‑Level Security
    * Общая политика: роли user и admin имеют доступ только к своим записям в auth.users. Отдельных RLS‑политик для public.users и auth.users не требуется: используем одну для схемы auth. 
    * Все запросы к данным пользователя идут по JWT и в БД автоматически подтягивается current_setting('jwt.claims.user_id') для фильтрации по user_id. 

2. База данных и миграции
1. PostgreSQL + миграции

    * Скрипты лежат в репозитории, при деплое CI/CD автоматически запускает dbmate up. 
    * Откатные скрипты (down) — только для локальной dev‑среды, в продакшене — только вперёд. 
1. Бэкапы и восстановление
    * Ежечасный снимок базы на объектное хранилище Cloudflare R2. 
    * RTO ≤ 30 мин, RPO ≤ 15 мин. 

3. Инфраструктура и CI/CD
1. Frontend
    * React + TypeScript + Vite для мгновенной сборки и HMR. 
    * Развёртывание: Cloudflare Pages (PR → preview, main → production). 
    * Linting/форматирование: ESLint + Prettier в CI. 
2. Backend & WebSockets
    * Node.js (TypeScript) + Express для REST‑API. 
    * ws или uWebSockets.js для WebSocket‑кластера. 
    * Балансировка через Cloudflare Tunnel + порт 443; подключений ≥ 5 000. Sticky sessions обеспечиваются по connect.sid, а при шардировании используем Pub/Sub (Cloudflare KV) для рассылки сообщений между инстансами. 
3. CI/CD
    * GitHub Actions:
        1. Проверка кода (lint, typecheck) 
        2. Деплой 

4. Мониторинг и логирование
* Prometheus + Alertmanager:
    * API latency P95, WS message rate, error rate 
    * Тревоги: warning при 300 ms P95, critical при 500 ms P95; ошибка WS reconnect > 5 сек. 
* Логи в JSON‑формате хранятся в Loki/Grafana, retention 14 дней. 
* Distributed tracing (OpenTelemetry → Jaeger) для REST‑запросов. 

5. API‑дизайн
1. Версионирование
    * /api/v1/... по REST для профиля, баланса, истории игр, создания комнат и других событий или сообщений. 
2. Идемпотентность
    * Эндпоинт создания комнаты и платежей принимает заголовок Idempotency-Key. 
3. Валидация
    * Zod для схем запросов/ответов. 
    * Ошибки отдаются в формате { code: string; message: string; details?: any }. 

6. Кэширование и i18n
* i18n: react-i18next, тексты на русском и английском. 
* Кэширование:
    * Cloudflare CDN для всех статики: JS/CSS, изображения (TTL 1 день). 
    * HTML-кеш (Edge‑rendered) с учётом языка и JWT — ttl 5 мин. 
* Service Worker не используется. 

7. TON Connect и платежи
1. Интеграция
    * Через @tonconnect/sdk в React: при первом входе происходит проверка уже существующего кошелька у пользователя связанного с telegram id если кошелька нет ничего не делаем потому что в профиле  показываем кнопку «Привязать кошелёк» в профиле если кошелька нет, если кошелек есть отображаем его в профиле  . 
    * Поле has_ton_wallet в users обновляется после успешного wallet.requestConnection(). Адрес сохраняется в таблицу wallets. 
2. Неудачные транзакции
    * Если пользователь закрыл окно транзакции: показываем мини‑модалку‑миниатюру «Продолжить» (прыгающую), плюс кнопку «Отменить». Состояние сохраняется в localStorage и на сервере. 

8. Игровая логика и античит
1. WebSocket‑протокол
    * Формат сообщений — JSON:   { "type": "taps", "user_id": "...", "count": 20, "timestamp": 1684320000000 }
    *    
    * Кадры (пакеты) отправляем при каждых 20 тапах или при таймауте 200 мс. 
2. Античит
    * Сервер считает скорость: если > 50 тапов за 2 сек, игрок помечается как читер и блокируется на текущую игру. 
    * Клиентские пакеты валидируются по таймстампам и user_id. 
3. Reconnect
    * При потере WS соединения клиент автоматически переподключается в фоне с экспоненциальным бэкоффом (200 мс → 1 с → 2 с → 5 с). 
    * После восстановления присылается полный статус прогресса. 
4. Реакции перед игрой
    * В комнате до старта игроки видят аватарки друг друга и могут кликнуть по фото, чтобы отправить случайный эмодзи‑реакцию всем участникам или кликать на свою аватарку чтоб излучать смайлики . 

9. UX: что видит пользователь
Этап	Экран и поведение
1. Запуск через бота	Бот присылает welcome‑сообщение на русском или на английском согласно гео данным с кнопкой «Вход в игру». Нажал — открылся web‑app открывается игра без дополнительных регистраций 
2. Главный экран	В шапке:слева вверху название приложение Chance Tap, аватар, имя, баланс . Шесть карточек комнат (20…500 Stars). Нижнее меню: Home(главная ) / Leaderboard (лидеры) / Profile (Профиль) / Create (Создать).
3. Выбор комнаты	При тапе по карточке: если недостаточно Баланса — автоматически стартует Telegram‑платёж Ton или выбор разных платежей, если средств достаточно попадает сразу в комнату где будет ждать всех игроков если в базе все комнаты заняты автоматически создается комната и туда помещается игрок и уже к этой комнате подключаются другие игроки ждем 60 секунд на сбор и подготовку всех игроков в режиме ожидания когда игроков это стандартная комната и когда набирается 10 игроков игра запускает таймер на старт внимание TAP это как отсчет 1,2,3. 
4. Ожидание	Заголовок с типом и ценой комнаты, счётчик участников (аватарки по полукругу с именемвсе игроки собираются  вокруг круглой кнопки для тапа  ), текст «Ожидаем X из Y игроков и таймеры 60 секунд на подготовку».
5. Начало игры	Стартует обратный отсчёт 3…1, прогресс‑бары по краям, центральная круглая кнопка «TAP». Таймер 60 с на игру .
6. Игра	Каждый тап мгновенно увеличивает локальный счётчик; пакеты по 20 тапов уходят на сервер; прогресс‑бары обновляются все игроки видят прогрейбар друг друга .
7. Результаты	Появляется победитель (аватар в центре) и призовой фонд. Две кнопки: «В лобби» и «Сыграть ещё».
8. Hero‑комната совсем другая логика	В Create(создать): выбор «Создать комнату» или войти,  при создании комнаты пользователь становится организатором и должен (задать сумму взноса  fee) когда организатор нажимает создать генерируется уникальный ключ который отображается у него на экране то есть появляется отдел где лежит этот уникальный ключ и организатор сможет поделится этим ключом с другими пользователями и активируется внизу экрана справа таймер который отсчитывает 5 минут если в течении пяти минут организатор не начинает игру комната автоматически удаляется и всем участникам возвращаются деньги назад а так же всех участников которые в комнате включая организатора выбрасывает на прошлую страницу автоматически хочу добавить что организатор может войти в комнату как организатор чтоб просто смотреть за процессом но принимать участие он не может так же организатор может в реальном времени видеть кто подключился к комнате все выстраиваются по кругу вокруг кнопки и у организатора должна быть кнопка старт или начать в этой комнате логика запуска игры происходит в ручном режиме Организатор создает комнату бесплатно и с него не берется оплата за вход в комнату потому что он приобретает статус организатор так же есть другое окно отдельно называется войти, когда пользователь нажимает  «Войти по ключу» он вводит ключ который передал ему организатор  автоматически взымается → оплата → и пользователь входит в комнату где видит в реальном времени других подключившихся игроков когда организатор считает что все игроки вошли он может начать игру и начинается отсчет старт внимание TAP где игрокам нужно тапать по кнопке , победитель определяется тот кто набирает 200 тапов или тот кто набрал больше всех тапов за 60 секунд игры таймер игры должен быть вверху слева когда игра завершается победитель получает 90%  банка а организатор получает 10% банка на счет 
Бонус комната	Кнопка «Start Bonus», прогресс‑бар (0/1 000 000), таймер 24 ч. При выполнении — +100 $ и возврат на Home прогрей или не завершенное событие можно наблюдать или отменить как в самой комнате бонуса так и в профиле пользователя .
10. Лидерборд	Топ‑10 за «Сегодня/Неделю/Все время» с аватаром, именем и суммой выигрыша.
11. Профиль	Баланс, адрес TON‑кошелька, статистика (выиграно), реферальная секция с кодом и списком рефералов. И отображение событий бонус комнаты если комната запущена если бонус комната не запущена отображение этого раздела не должно быть 


вот дополнение 

Ключевые особенности Hero-комнат
Уникальный 6-символьный ключ (буквы+цифры)
Максимум 30 участников
Таймер ожидания: 5 минут
Ручной запуск организатором
Автоматическая очистка при истечении времени

Основные функции
 Генерация ключа комнаты
generateUniqueRoomKey(): создает уникальный ключ формата XXXXXX
Проверка уникальности в БД
Алгоритм генерации: случайный выбор из 36 символов (A-Z0-9)
Очистка комнат

* Я ещё раз проглядел весь сценарий и вот как я его сейчас вижу:
Создание Hero‑комнаты
Организатор задаёт только entry_fee, нажимает «Создать» и тут же получает room_key + запускается таймер 5 мин.
Комната отображается в статусе waiting, max_players = 30.
Присоединение участников
Участник вводит ключ и присоединяется, как только с него списалась плата.
Пока организаций не нажал «Начать», все в статусе ожидания: видят аватарки, но взаимодействовать нельзя.
Запуск игры
Как только организатор считает, что все пришли (либо просто сам нажимает «Начать» по своему усмотрению), статус переводится в active.
Появляется центральная кнопка «TAP» + обратный отсчёт 30 сек когда проходит 27 секунд возникает из неоткуда на старт потом эта запись пропадает появляется внимание потом эта запись пропадает появляется TAP получется что 3 последние секунды отображаются словами и потом начинается игра таймер запускается еще на 30 секунд и пользователи должны тапать по кнопке
Игровой раунд
Каждый тап увеличивает локальный счётчик и ~каждые 50 мс шлёт батч на сервер.
Сервер аггрегирует и рассылает обновлённые показатели всем игрокам, прогресс‑бары подстраиваются.
Завершение
Игра останавливается по таймеру (30 сек) или при достижении 200 тапов любым из игроков.
Сервер определяет победителя, переводит статус → finished, распределяет приз (90% игроку, 10% — разработчику не организатору а разработчику приложения ).
Поведение при истечении 5 мин ожидания
Если организатор не запустил игру до истечения 5 мин, cron переводит комнату в expired (и удаляет её вместе с участниками).
Участники получают уведомление и возвращаются на главный экран при этом сумма ставки возвращается всем участникам .
Возможные вопросы для уточнения
Заполнение комнаты vs время
Должна ли игра автоматически стартовать при наборе 30 участников (без нажатия «Начать»)? нет участников в hero комнате может быть до 30 человек и они не должны стартовать пока организатор не нажмет кнопку начать
Что если за 5 мин набралось меньше 30 игроков, но организатор всё же хочет запустить игру? он может запустить игру даже если будет один участник
Поведение организатора
Организатор может запустить игру в любой момент до истечения 5 мин, даже если в комнате, скажем, только 2–3 участника? да именно так
Выход из комнаты до старта
Если участник покидает комнату до запуска, он теряет ставку и просто удаляется из participants?
Поведение mid‑game
Что если игрок отключился или закрыл мини‑приложение во время раунда? Должна ли его кнопка «TAP» становиться неактивной, а прогресс‑бар отображать последнее значение? да именно так и должно происходить если во время раунда пользователь отключается или закрывает мини приложение ему деньги уже не возвращаются и он деактивируется и теряет ставку и просто удаляется из participants
Как обрабатываются «нетронутые» тайминги при задержках сети?
Сервер определяет время начала отсчета. Это время отправляется всем клиентам. Клиенты синхронизируют свои таймеры с сервером. Независимо от задержек, все видят одинаковое оставшееся время
так же
локально серверная синхранизация для обработки событий чтоб обеспечить мгновенный отклик тапов и отображение точно результата у всех игроков
Ничья
Если два игрока одновременно достигают 200 тапов в пределах одного батча, как сервер определяет победителя? если у пользователей одинаковое количество тапов обьявляется дополнительный раунд для этих участников где участники которые набрали меньше тапов чем победители просто исключаются из игры оставляя свой банк в игре потому что по логике они уже проиграли и попадают на главную страницу а те у частники для кого обьявлен второй раунд начинают борьбу заново чтоб выяснить кто все таки заберет 90% банка
Стандартные комнаты
В чём принципиальное отличие «standard» от «hero»? Такая же логика по ключу, но без ручного создания? Или механизм автоподбора? hero:
Комната создаётся вручную одним пользователем‑организатором.
Он получает уникальный ключ и лично приглашает в неё друзей или делится ключом.
Все присоединяются по этому ключу в течение отведённых 15 минут.
standard:
Это «обычные» платные комнаты, которые не создаются под конкретного организатора.
Пользователь просто выбирает размер ставки (entry_fee), а система автоматически подбирает ему комнату с другими участниками, уже ожидающими начала игры.
Здесь нет ключа и ручного создания — за matchmaking отвечает сервер.
bonus:
Специальная бесплатная комната для одного пользователя с долгим челленджем (10 млн тапов за 24 ч).
Бонусная комната
Там тоже 30 сек раунд, но без платы. После чего даётся фиксированный приз (3 000 Stars)? бонус комната где по логике участник может быть только один и он должен сделать 10000000 тапов за 24 часа тогда он получает вознаграждение то есть пользователь нажимает кнопку начать и запускается таймер исключительно для него даже если пользователь закрывает приожение или выходит из него все равно таймер должен быть сохранен и когда пользователь входит он должен видеть сколько реально осталось времени до завершения челенжа
История и повторные игры
После окончания раунда и перехода в finished, организатор и участники видят кнопку «Сыграть ещё» или «В лобби» — нужно ли автоматизировать поиск новой комнаты или просто вернуть в главное меню? в случае с стандартной комнатой должна быть такая запись «Сыграть ещё» или «В лобби» если пользователь нажимает на кнопку сыграть еще то происходит автоподбор комнаты с такой же ставкой где может быть только 10 участников то есть с пользователя повторно списывается деньги с баланса если они есть и ему подбирается комната если пользователь нажимает в лобби то он выходит в главный экран
Пожалуйста, уточните эти моменты, чтобы мы точно описали логику и автоматизировали все сценарии.             При первом входе
* Сохранение/проверка пользователя
    * При первом заходе в мини-приложение через Telegram Mini-App SDK выполняется POST /api/user/init.
        * Если telegram_id отсутствует в таблице users → создаётся новая запись с balance_stars = 0, has_ton_wallet = false и остальными полями по умолчанию. 
        * Если запись уже есть → возвращается существующий профиль без изменений. 
    * Для всех запросов далее пользователь получает JWT-токен. 
* Получение профиля
    * GET /api/user/me → возвращает { id, username, avatar_url, has_ton_wallet, balance_stars }. 
    * Фронтенд Mini-App при загрузке главной страницы и в профиле запрашивает этот эндпоинт и отображает реальные данные вместо мок-объектов. 

Создание «Hero-комнаты»
1. Инициация
    * Организатор нажимает «Создать Hero-комнату» и вводит только entry_fee. 
    * Отправляется POST /api/rooms с телом { type: 'hero', entry_fee }. 
2. Сохранение в базе sql    INSERT INTO rooms (creator_id, type, room_key, entry_fee, max_players)
3. VALUES ($1, 'hero', nanoid(), $2, 30)
4. RETURNING room_key, created_at;
5.    
6. UI-ответ
    * Появляется модал с текстом: «В вашу комнату может зайти до 30 игроков по ключу <room_key>. Время жизни — 10 мин.»  
    * Стартует таймер обратного отсчёта 10:00 → 00:00. 
    * Появляется кнопка «Войти в комнату» для организатора (переход сразу в лобби комнаты). 
7. Авто-протухание
    * По крону node-cron каждые 5 мин: sql   UPDATE rooms
    * SET status = 'expired'
    * WHERE type = 'hero'
    *   AND status = 'waiting'
    *   AND created_at < now() - interval ’10 minutes';
    * 
    * DELETE FROM participants
    * WHERE room_id IN (
    *   SELECT id FROM rooms WHERE status = 'expired'
    * );
    * 
    * DELETE FROM rooms WHERE status = 'expired';
    *    
    * При попытке доступа по истёкшему ключу фронтенд показывает ошибку что организатор не начал игру за отведенное время у ведомление «свяжитесь с организатором » и кнопка ввести другой ключ или кнопка возвращает на главную страницу . 
    * Всем участникам возвращается их ставка автоматически при условии если организатор не начал игру . 

Присоединение участников
1. Форма входа
    * На главном экране кнопка «Войти в Hero-комнату». 
    * Открывается модал с полем ввода room_key и кнопкой «Войти в комнату». 
2. API-запрос
    * POST /api/rooms/join с телом { room_key }, заголовок Authorization: Bearer <JWT>. 
    * Сервер проверяет:
        * room.type = 'hero' и status = 'waiting'. 
        * participants.count < max_players. 
        * У пользователя достаточно balance_stars для удержания entry_fee.
        * Если у пользователя не достаточно баланса появляется  модалка с пополнением счета для участия в игре 
3. Добавление sql   INSERT INTO participants (room_id, user_id)
4. VALUES ($roomId, $userId);
5.    — и одновременно удержание ставки у пользователя (через транзакцию в transactions). 
6. UI-перевод
    * Участник попадает в комнату которую создал организатор:
        * Видит аватарки всех присоединившихся. 
        * Кнопка «Начать» доступна только организатору. 

Запуск и игровой процесс
1. Запуск
    * Организатор в любой момент до истечения 10 мин нажимает «Начать». 
    * PATCH /api/rooms/:id/start → UPDATE rooms SET status = 'active'. 
2. Предстартовая анимация
    * Сразу после клика появляется:
        * 30-секундный обратный отсчёт когда таймер доходит до 3 секунд последние три секунды обьявляються словами Старт , внимание , TAP  
        * Затем начинается основной таймер 30 сек. 
3. Раунд
    * Центральная кнопка «TAP» (≈30 % экрана). 
    * Клиент: каждый тап инкрементирует локальный счётчик, батчит (~50 мс) на сервер. 
    * Сервер агрегирует, рассылает обновлённые данные всем игрокам, прогресс-бары плавно анимируются. 
4. Завершение
    * Раунд останавливается при любом из условий:
        * Таймер 30 сек истёк. 
        * Любой игрок набрал 200 тапов. 
    * Сервер:
        * Определяет победителя. 
        * UPDATE rooms SET status = 'finished'. 
        * Распределяет приз: 90 % — победителю, 10 % — разработчику приложения. 
        * Фиксирует транзакции в таблице transactions. 
5. Ничья
    * Если в одном батче двое достигли 200 тапов одновременно:
        * Основная игра останавливается. 
        * Генерируется новый «баттл» только между этими участниками. 
        * Проигравшие из первого раунда исключаются: их ставка остаётся в общем фонде. 
        * Победитель второго раунда забирает весь оставшийся банк. 

Поведение вне раунда и ошибки
* Выход до старта
    * Участник, покинувший самостоятельно комнату hero и комнату стандартная  до старта, теряет ставку, удаляется из participants. 
* Отключение mid-game
    * Если клиент отключился во время раунда:
        * Его кнопка «TAP» деактивируется. 
        * Прогресс-бар замирает на последнем значении. 
        * Ставка не возвращается. 
* Синхронизация таймеров
    * Сервер формирует метку start_time и раздаёт её клиентам. 
    * Клиенты синхронизируют свои таймеры по этому времени, компенсируя задержки сети. 

Отличия типов комнат
Тип	Механика создания	Matchmaking	Участники	Плата	Таймер ожидания
hero	Организатор вручную	По ключу, ручной вход до 5 мин	До 30	Выбор entry_fee	5 мин
standard	Авто-подбор по ставке	Сервер автоматически подбирает до 10	До 10	Выбор entry_fee	Нет (до набора)
bonus	Для одного игрока	–	1	Бесплатно	24 ч (для челленджа)

Bonus-комната
* Старт: кнопка «Start Bonus» запускает 24-часовой таймер. 
* Цель: 10 000 000 тапов за 24 ч. 
* Автопродолжение: при повторном входе пользователь видит остаток времени и прогресс. 
* Награда: 100$  при выполнении челленджа. 
* После фейла: уведомление «вам не удалось выполнить челендж»  сбрасывает прогресс и таймер. До следующего начала нажатия кнопки «Start Bonus»   стандартная комната 
«Сыграть ещё» и «В лобби»
1. Standard Room
    * Кнопки «Сыграть ещё» или «В лобби» после окончания. 
    * «Сыграть ещё» → авто-подбор новой комнаты с той же ставкой (списание повторно). 
    * «В лобби» → возврат на главный экран без списаний. 
2. Hero & Bonus
    * «В лобби» → на главный экран. 
    * «Сыграть ещё» не применяется (новая Hero-комната создаётся отдельно). 

Безопасность и валидация
* JWT-аутентификация для всех эндпоинтов. 
* Валидация:
    * entry_fee > 0 
    * Корректность room_key (регулярное выражение). 
* Параметризованные запросы (node-postgres). 
* HTTPS на уровне прокси/балансировщика. 

         При первом входе
Сохранение/проверка пользователя
* POST /api/user/init через Telegram Mini-App SDK:
    * При отсутствии telegram_id в users создаётся запись с balance_stars = 0, has_ton_wallet = false и остальными полями по умолчанию. 
    * Если запись уже есть, возвращается существующий профиль без изменений. 
* После успешного init клиенту выдаётся JWT-токен для авторизации всех последующих запросов. 
Получение профиля
* GET /api/user/me → возвращает { id, username, avatar_url, has_ton_wallet, balance_stars }. 
* Фронтенд Mini-App при загрузке главной страницы и в профиле запрашивает этот эндпоинт и отображает реальные данные вместо заглушек. 

Создание «Hero-комнаты»
1. Инициация
* Перед созданием проверяется, что организатор не имеет другой комнаты в статусе waiting или active. Если такая есть — возвращается ошибка 409 Conflict с сообщением «У вас уже есть открытая комната». 
* Организатор нажимает «Создать Hero-комнату» и вводит только entry_fee. 
* Отправляется POST /api/rooms с телом { type: 'hero', entry_fee }. 
2. Сохранение в базе**
INSERT INTO rooms (creator_id, type, room_key, entry_fee, max_players)
VALUES ($1, 'hero', nanoid(), $2, 30)
RETURNING room_key, created_at;
3. UI-ответ
* Модал с текстом: «В вашу комнату может зайти до 30 игроков по ключу <room_key>. Время жизни — 10 минут.»  
* Автоматический таймер обратного отсчёта 10:00 → 00:00. 
* Кнопка «Войти в комнату» для организатора (переход сразу в лобби). 
4. Авто-протухание (cron)
UPDATE rooms
SET status = 'expired'
WHERE type = 'hero'
  AND status = 'waiting'
  AND created_at < now() - interval '10 minutes';

DELETE FROM participants
WHERE room_id IN (
  SELECT id FROM rooms WHERE status = 'expired'
);

DELETE FROM rooms
WHERE status = 'expired';
* При попытке доступа по истёкшему ключу фронтенд выводит сообщение: «Организатор не запустил игру вовремя. Свяжитесь с организатором или введите другой ключ.»  
* Кнопки «Ввести другой ключ» и «На главную». 
* Ставки возвращаются всем участникам, если организатор не нажал «Начать». 

Присоединение участников
1. Форма входа
* Кнопка «Войти в Hero‑комнату» на главном экране. 
* Модал с полем room_key и кнопкой «Войти в комнату». 
2. API-запрос
* POST /api/rooms/join { room_key }, заголовок Authorization: Bearer <JWT>. 
* Проверки на сервере:
    * room.type = 'hero' и status = 'waiting'. 
    * participants.count < max_players. 
    * У пользователя достаточно balance_stars для удержания entry_fee. 
    * Иначе показывается модал «Недостаточно средств» с кнопкой пополнения. 
3. Добавление участника
INSERT INTO participants (room_id, user_id)
VALUES ($roomId, $userId);
* В рамках транзакции создаётся запись в transactions и удерживается entry_fee. 
4. UI-перевод
* Участник попадает в лобби организатора:
    * Отображаются аватарки всех присоединившихся. 
    * Кнопка «Начать» доступна только организатору. 

Запуск и игровой процесс
1. Запуск
* Организатор нажимает «Начать» в любой момент до истечения 10 минут. 
* PATCH /api/rooms/:id/start → UPDATE rooms SET status = 'active'. 
2. Предстартовая анимация
* 30-секундный обратный отсчёт. 
* На последние 3 секунды объявление словами: «Старт», «Внимание», «TAP». 
* После — основной таймер 30 сек. 
3. Раунд
* Центральная кнопка «TAP» (~30% экрана). 
* Клиент: локальный счётчик, батч-запросы ~50 мс. 
* Сервер агрегирует и рассылает прогресс, клиенты плавно обновляют бары. 
4. Завершение
* Раунд останавливается при любом из условий:
    * Истечении 30 сек; 
    * Наборе 200 тапов любым игроком. 
* Сервер:
    * Определяет победителя; 
    * UPDATE rooms SET status = 'finished'; 
    * Распределяет призовой фонд в зависимости от типа комнаты:
        * Для standard и bonus комнат: 90% — победителю, 10% — разработчику приложения; 
        * Для hero комнаты: 90% — победителю, 7% — организатору, 3% — разработчику приложения; 
    * Создаёт записи в transactions согласно распределению; 
5. Ничья. Ничья**
* Если в одном батче двое или более игроков одновременно достигают 200 тапов:
    * Основной раунд останавливается. 
    * Генерируется новый «баттл» только между этими участниками. 
    * Проигравшие первого раунда исключаются (их ставки остаются в фонде). 
    * Победитель второго раунда забирает оставшийся банк. 
* Данная логика применяется как для hero, так и для standard комнат. 

Поведение вне раунда и ошибки
* Выход до старта: участник теряет ставку, удаляется из participants. 
* Отключение mid-game:
    * Кнопка «TAP» деактивируется; 
    * Прогресс-бар замирает; 
    * Ставка не возвращается. 
* Синхронизация таймеров:
    * Сервер раздаёт start_time клиентам; 
    * Клиенты компенсируют задержки сети. 

Отличия типов комнат
Тип	Механика создания	Matchmaking	Участники	Плата	Таймер ожидания
hero	Организатор вручную	По ключу до 10 мин	До 30	Ввод entry_fee	10 мин
standard	Авто-подбор по ставке	Автоматический подбор до 10	До 10	Ввод entry_fee	Нет
bonus	Для одного игрока	—	1	Бесплатно	24 ч
Bonus-комната
* Старт: кнопка «Start Bonus» запускает 24-часовой таймер. 
* Цель: 10 000 000 тапов за 24 ч. 
* Автопродолжение: при повторном входе сохраняются прогресс и остаток времени. 
* Награда: 3 000 Stars при успешном выполнении. 
* После фейла: уведомление «Вам не удалось выполнить челлендж». Сброс прогресса и таймера до нового старта. 

«Сыграть ещё» и «В лобби»
1. Standard Room
* Кнопки «Сыграть ещё» или «В лобби» после окончания. 
* «Сыграть ещё» → авто-подбор новой комнаты с той же ставкой (новое удержание). 
* «В лобби» → на главный экран без списаний. 
2. Hero & Bonus
* «В лобби» → на главный экран. 
* «Сыграть ещё» не применяется (новая Hero-комната создаётся отдельно). 

Защита от спуфинга тапов
* Серверная валидация частоты тапов: ограничение на максимально допустимую частоту — 15 тапов в секунду. При превышении происходит автоматический бан пользователя. такая логи должна быть у всех комнатах hero , standard, bonus

* Геозащита: блокировка входящих соединений через VPN/TOR (отклонение запросов по IP-адресам, подпадающим под списки VPN/TOR). 
Безопасность и валидация
* JWT-аутентификация для всех эндпоинтов. 
* Валидация:
    * entry_fee > 0; 
    * Корректность room_key (регулярка). 
* Параметризованные запросы (node-postgres). 
* HTTPS на уровне прокси/балансировщика. 



теперь напиши полностью все тех задание и учти что разробатывать я буду через cloufager tunnel где буду вводить команду для фронтенда и бекенда 
cloudflared tunnel --url http://localhost:5173
cloudflared tunnel --url http://localhost:3001


ChatGPT сказал:
Ниже приведён полный свёрнутый технический документ, учитывающий все ваши пожелания и особенности разработки через Cloudflare Tunnel (команды для фронтенда и бекенда).

1. Аутентификация и безопасность
1.1. Регистрация / логин через Telegram Mini‑App
При нажатии кнопки «Старт» в Telegram‑боте происходит вызов webhook и извлечение данных из telegram-web-app.js:

telegram_id, username, first_name, last_name, photo_url, опционально phone_number.

Если в auth.users нет записи с таким telegram_id — создаём новую запись в рамках одной транзакции (retry до 3 раз, логируем ошибки в Prometheus/Sentry).

После создания/нахождения пользователя генерируем JWT (HMAC‑SHA256, секрет из env). Токен привязан к telegram_id.

1.2. Row‑Level Security
Общая политика RLS для схемы auth: роли user и admin видят только свои записи.

В каждом запросе используется current_setting('jwt.claims.user_id') для фильтрации по user_id.

1.3. Защита от спуфинга и геозащита
Лимит частоты тапов: не более 15 тапов/сек; превышение → блокировка пользователя.

Отклонение запросов с IP, попадающих в списки VPN/TOR.

1.4. HTTPS и валидация
Все соединения через HTTPS на уровне прокси/балансировщика.

Валидация входных данных (entry_fee > 0, room_key по regex) через Zod на бэкенде.

Параметризованные SQL‑запросы (node-postgres).

2. База данных и миграции
2.1. PostgreSQL + миграции
Скрипты в репозитории; CI/CD запускает dbmate up при деплое.

Откатные скрипты (down) доступны только в локальной dev‑среде.

2.2. Бэкапы и восстановление
Ежечасные снимки в Cloudflare R2.

RTO ≤ 30 мин, RPO ≤ 15 мин.

3. Инфраструктура и CI/CD
3.1. Frontend
React + TypeScript + Vite.

Деплой через Cloudflare Pages:

main → production,

PR → preview.

Линтинг/форматирование: ESLint + Prettier.

3.1.1. Разработка локально через Tunnel
bash
Копировать
Редактировать
# Frontend
cloudflared tunnel --url http://localhost:5173
3.2. Backend & WebSockets
Node.js (TypeScript) + Express для REST API.

WebSocket‑кластер на ws или uWebSockets.js.

Балансировка через Cloudflare Tunnel на порт 443, sticky sessions через connect.sid, Pub/Sub на Cloudflare KV.

3.2.1. Разработка локально через Tunnel
bash
Копировать
Редактировать
# Backend
cloudflared tunnel --url http://localhost:3001
3.3. CI/CD (GitHub Actions)
Lint + typecheck

Деплой (Pages + сервер)

4. Мониторинг и логирование
Prometheus + Alertmanager:

Метрики: P95 latency API, WS message rate, error rate

Триггеры: warning при P95 ≥ 300 ms, critical при P95 ≥ 500 ms, WS reconnect > 5 с

Логи: JSON в Loki/Grafana, retention 14 дней.

Distributed Tracing: OpenTelemetry → Jaeger.

5. API‑дизайн
5.1. Версионирование
Все эндпоинты под /api/v1/....

5.2. Идемпотентность
Эндпоинты создания комнат и платежей принимают Idempotency-Key.

5.3. Схемы и ошибки
Валидация запросов/ответов через Zod.

Формат ошибок:

json
Копировать
Редактировать
{ "code": string, "message": string, "details"?: any }
6. Кэширование и i18n
i18n: react‑i18next, поддержка RU/EN.

CDN: Cloudflare CDN для статики (TTL = 1 день).

Edge‑rendered HTML: кеш на 5 мин с учётом языка и JWT.

Service Worker не используется.

7. TON Connect и платежи
7.1. Интеграция через @tonconnect/sdk
При первом входе проверяем has_ton_wallet.

Если кошелька нет — в профиле показываем кнопку «Привязать кошелёк».

После wallet.requestConnection() обновляем has_ton_wallet и сохраняем адрес в таблицу wallets.

7.2. Транзакции
При закрытии окна транзакции — показываем мини‑модал «Продолжить» + «Отменить».

Состояние сохраняется в localStorage и на сервере.

8. Игровая логика и античит
8.1. WebSocket‑протокол
Формат сообщений:

json
Копировать
Редактировать
{ "type": "taps", "user_id": "...", "count": 20, "timestamp": 1684320000000 }
Пакеты: либо каждые 20 тапов, либо каждые 50 мс.

8.2. Античит
Сервер проверяет скорость: > 15 тапов/сек → блокировка.

Валидация timestamp и user_id на стороне сервера.

8.3. Reconnect
При потере соединения — экспоненциальный бэкофф (200 мс → 1 с → 2 с → 5 с).

По восстановления — клиент получает полный статус прогресса.

9. Типы комнат и пользовательский флоу
Тип	Создание	Matchmaking	Участники	Плата	Ожидание
hero	Организатор вручную	По ключу (до 30 чел)	До 30	Выбор entry_fee	5 мин (10 мин в финальной)
standard	Авто-подбор по ставке	Автоматически до 10	До 10	Выбор entry_fee	—
bonus	Для одного игрока	—	1	Бесплатно	24 ч

9.1. Flow Hero‑комнаты
Создание

Организатор вводит entry_fee → POST /api/rooms { type: 'hero', entry_fee }.

В БД:

sql
Копировать
Редактировать
INSERT INTO rooms (creator_id, type, room_key, entry_fee, max_players)
  VALUES ($1, 'hero', nanoid(), $2, 30)
  RETURNING room_key, created_at;
UI: модал «Ключ: <room_key>, время жизни — 10 мин», таймер, кнопка «Войти в комнату».

Авто‑протухание

Cron каждые 5 мин:

sql
Копировать
Редактировать
UPDATE rooms 
SET status = 'expired' 
WHERE type='hero' AND status='waiting' AND created_at < now() - interval '10 minutes';
DELETE FROM participants WHERE room_id IN (...);
DELETE FROM rooms WHERE status='expired';
Уведомление об истечении, возврат ставок.

Присоединение

Участник вводит room_key → POST /api/rooms/jjoin.

Проверки: тип/статус комнаты, participants.count < max_players, достаточный баланс.

UI: отображение аватарок, кнопка «Начать» для организатора.

Запуск и игра

Организатор нажимает «Начать» → PATCH /api/rooms/:id/start, статус active.

Предстарт: 30 с, последние 3 с — «Старт», «Внимание», «TAP».

Раунд: 30 с или до 200 тапов.

Завершение: определение победителя, обновление status = 'finished', распределение призового фонда:

Hero: 90% победителю, 7% организатору, 3% разработчику.

Standard/Bonus: 90% победителю, 10% разработчику.

Ничья → дополнительный баттл между лидерами.

Ошибки и выходы

Выход до старта → потеря ставки.

Отключение mid‑game → деактивация кнопки, прогресс-бар замер, ставка не возвращается.

Синхронизация таймеров через start_time от сервера.

9.2. Flow Standard‑комнаты
Авто-подбор по ставке, до 10 участников.

Кнопки после игры: «Сыграть ещё» (списание повторно, подбор), «В лобби» (главный экран).

9.3. Flow Bonus‑комнаты
Кнопка «Start Bonus» → 24‑часовой таймер, цель — 10 000 000 тапов.

При пересборе: сохраняется прогресс и остаток времени.

Награда — 3 000 Stars.

Неудача → сброс прогресса, уведомление, можно начать снова.

10. Дополнительные вопросы и уточнения
Авто‑старт Hero‑комнаты при 30 участниках? Нет, только по кнопке организатора.

Организатор может стартовать при любом количестве участников? Да.

Выход участника до старта → потеря ставки? Да.

Ничья: дополнительный раунд между равными.

Срок ожидания Hero: 5 мин (в финальной версии — 10 мин).

Примечание по локальной разработке через Cloudflare Tunnel:

bash
Копировать
Редактировать
# Для фронтенда:
cloudflared tunnel --url http://localhost:5173
# Для бекенда:
cloudflared tunnel --url http://localhost:3001
Хорошо, я получил задание создать детальное техническое задание для игрового приложения с различными типами комнат и интеграцией с Telegram. Мне нужно учесть все аспекты: аутентификацию, базу данных, инфраструктуру, игровую логику, интерфейс и особенности использования Cloudflare Tunnel.

Сначала я должен понять общую структуру проекта. Вижу, что пользователь взаимодействует через Telegram бота, который открывает веб-приложение. Аутентификация происходит через Telegram ID, и данные пользователя сохраняются в базе данных PostgreSQL. Нужно настроить RLS (Row-Level Security), чтобы пользователи имели доступ только к своим данным.

Далее, инфраструктура: фронтенд на React с TypeScript и Vite, бекенд на Node.js с Express и WebSockets. Деплой через Cloudflare Pages и использование Cloudflare Tunnel для локальной разработки. Нужно прописать команды для запуска туннелей для фронта и бекенда.

Особое внимание требуется к разным типам комнат: стандартные, Hero и бонусные. В Hero-комнатах организатор создает комнату с уникальным ключом, участники присоединяются по ключу, есть таймер ожидания и ручной запуск игры. Надо продумать таблицы в базе данных для комнат и участников, логику создания и присоединения, обработку платежей, античит-механизмы и распределение призов.

Важно детально описать пользовательский интерфейс на каждом этапе: главный экран, выбор комнаты, ожидание игроков, игровой процесс, результаты. Учесть различные сценарии: недостаток баланса, возврат средств при истечении времени, обработка отключений во время игры.

Нужно также предусмотреть мониторинг и логирование, интеграцию с TON для платежей, многоязычную поддержку и кэширование. Всё это должно быть структурировано в виде технического задания с таблицами, схемами баз данных и пошаговым описанием процессов.

Могу ли я что-то упустить? Возможно, детали реализации WebSocket-сервера или особенности работы с Cloudflare KV для шардирования. Стоит проверить, все ли endpoints описаны, корректны ли SQL-запросы, учтены ли все возможные состояния комнат и пользователей. Также важно убедиться, что логика обработки ничьих и дополнительных раундов четко прописана.

В итоге, техническое задание должно быть достаточно подробным, чтобы разработчик мог по нему реализовать проект без дополнительных уточнений, включая все необходимые таблицы, API endpoints, процессы и взаимодействия между компонентами системы.

Техническое задание: Многопользовательская игровая платформа с комнатами (Standard, Hero, Bonus)

1. Обзор системы
Платформа для создания/вступления в игровые комнаты с механикой тапов.
Ключевые компоненты:

Аутентификация через Telegram Mini Apps.

3 типа комнат: Standard (автоподбор), Hero (ручное создание), Bonus (индивидуальный челлендж).

Интеграция с TON для платежей.

WebSocket для реального взаимодействия.

Cloudflare Tunnel для деплоя и разработки.

2. Архитектура
2.1. Схема инфраструктуры
Frontend (React) → Cloudflare Pages  
Backend (Node.js) → Cloudflare Tunnel (WS/REST)  
PostgreSQL → Cloudflare R2 (бэкапы)  
Prometheus/Grafana → Мониторинг  
Локальная разработка:

bash
# Frontend
cloudflared tunnel --url http://localhost:5173

# Backend
cloudflared tunnel --url http://localhost:3001
3. База данных
3.1. Таблицы
Таблица	Колонки	Описание
auth.users	id (UUID), telegram_id (str), username (str), balance_stars (int), ...	Основные данные пользователей.
rooms	id (UUID), type (enum), room_key (str), entry_fee (int), status (enum)...	Информация о комнатах.
participants	id (UUID), room_id (UUID), user_id (UUID), tap_count (int)...	Участники комнат и их прогресс.
transactions	id (UUID), user_id (UUID), amount (int), type (enum)...	История финансовых операций.
wallets	user_id (UUID), ton_address (str)...	Привязанные TON-кошельки.
Статусы комнат: waiting, active, finished, expired.

3.2. Миграции
Используется dbmate для управления схемой.

Пример создания таблицы rooms:

sql
CREATE TABLE rooms (
    id UUID PRIMARY KEY,
    creator_id UUID REFERENCES auth.users(id),
    type VARCHAR(10) NOT NULL,
    room_key VARCHAR(6) UNIQUE,
    entry_fee INT NOT NULL,
    max_players INT,
    status VARCHAR(10) DEFAULT 'waiting',
    created_at TIMESTAMP DEFAULT NOW()
);
4. API Endpoints
4.1. Пользователи
POST /api/v1/user/init – Инициализация пользователя через Telegram.

GET /api/v1/user/me – Получение профиля.

4.2. Комнаты
POST /api/v1/rooms – Создание комнаты (тип: hero/standard/bonus).

POST /api/v1/rooms/join – Присоединение к комнате.

PATCH /api/v1/rooms/{id}/start – Запуск игры (для Hero).

4.3. Платежи
POST /api/v1/payments/deposit – Пополнение баланса через TON.

5. Игровая логика
5.1. Hero-комната
Создание:

Организатор задает entry_fee, генерируется room_key (6 символов).

Таймер ожидания: 10 мин.

Присоединение:

Участники вводят room_key, списывается entry_fee.

Запуск:

Организатор вручную стартует игру.

Игра длится 30 сек или до 200 тапов.

Распределение призов:

Победитель: 90%, Организатор: 7%, Платформа: 3%.

5.2. Стандартная комната
Автоподбор игроков (до 10 человек).

Автоматический старт при заполнении.

5.3. Бонусная комната
Индивидуальный челлендж: 10M тапов за 24 часа.

Награда: 3000 Stars.

6. Пользовательский интерфейс
6.1. Этапы взаимодействия
Этап	Экран	Действия
Главный экран	6 карточек комнат, баланс, аватар.	Выбор комнаты / создание Hero.
Ожидание игроков	Аватарки участников, таймер, кнопка "Начать" (для организатора).	Отправка реакций, чат (опционально).
Игра	Круглая кнопка "TAP", прогресс-бары, таймер.	Тапы, обновление статистики в реальном времени.
Результаты	Аватар победителя, призовой фонд, кнопки "Сыграть ещё" / "В лобби".	Переход в лобби или повторный поиск.
7. Безопасность
JWT-токены: Подпись HMAC-SHA256, валидация на каждом запросе.

RLS: Политики PostgreSQL для изоляции данных.

Античит:

Лимит: 15 тапов/сек.

Геоблокировка VPN/TOR.

8. Мониторинг
Метрики: Задержка API, активные WS-соединения, ошибки.

Логи: Хранение в Loki, визуализация в Grafana.

Трассировка: OpenTelemetry → Jaeger.

9. CI/CD
GitHub Actions:

Линтинг кода (ESLint, Prettier).

Сборка фронтенда и деплой на Cloudflare Pages.

Деплой бекенда через Cloudflare Tunnel.

10. Особые сценарии
Истечение времени Hero-комнаты: Возврат средств, уведомление.

Ничья: Дополнительный раунд между лидерами.

Отключение игрока: Заморозка прогресса, деактивация кнопки.

Приложения:

ER-диаграмма базы данных.

Примеры WebSocket-сообщений.

Детали настройки Cloudflare Tunnel.

[End of Document]

This response is AI-generated, for reference only.
да продолжи но внеси еще то что ты не видел 

Краткий обзор
Вы получаете:
* Frontend: React + TypeScript + Vite для мгновенной сборки и HMR Mediumvitejs. 
* Telegram Mini App SDK: telegram-web-app.js для авторизации, оплаты и взаимодействия с Canvas Telegram APIs. 
* Realtime-синхронизация: PostgreSQL Realtime (WebSocket) для мгновенного обмена данными между игроками PostgreSQL 
* TON Connect: клиентская JS-библиотека для создания и управления TON-кошельком пользователя Start | The Open NetworkGitHub. 
* Backend: Node.js + PostgreSQL для API, авторизации и операций с БД PostgreSQL
* 
* Code Quality: ESLint + Prettier для единых стандартов кода DEV Community. 
* Hosting: Cloudflare Pages — мгновенный деплой и глобальный CDN Cloudflare Pages. 

1. Полный стек без кода
* React + TypeScript + Vite: современный фронтенд со сверхбыстрой сборкой и HMR Mediumvitejs. 
* Telegram Mini Apps JS SDK (telegram-web-app.js): интеграция с Telegram-клиентом, опции оплат и локальное хранилище Telegram APIs. 
* TON Connect JS SDK (@tonconnect/sdk, @tonconnect/ui-react): создание и управление TON-кошельком, подтверждение транзакций Start | The Open NetworkGitHub. 

    * PostgreSQL с таблицами, RLS и функциями. 
    * Realtime: глобальный WebSocket-кластер для Broadcast, Presence и Postgres  
* Backend: Node.js (Express/Fastify) + REST API, аутентификации и бизнес-логики PostgreSQL 
* ESLint + Prettier: linting и форматирование на лету, настройки в .eslintrc.* и .prettierrc DEV Community. 
* Cloudflare Pages: деплой фронтенда и Edge Functions (при необходимости) с мгновенным CDN и SSL Cloudflare Pages.  Create a secure user authentication flow in a Telegram application that:
1. When a user enters the app:
    * Allow anonymous record creation in public.users table
    * Capture user's UUID and telegram_id
2. Perform automatic verification:
    * Check if user exists in auth.users table
    * If no record exists:
        * Copy UUID from public.users to auth.users
        * Set telegram_id as phone in auth.users
        * Copy username from public.users to display_name in auth.users
3. Security requirements:
    * Process should run automatically on each login
    * No user intervention required
    * Ensure users can only access their own records
    * Maintain data consistency between public.users and auth.users tables
Please provide the implementation logic to handle this authentication flow while maintaining data security and user privacy.
* 

2. Визуальная структура папок
plaintext
КопироватьРедактировать
project-root/
├─ public/                      # Статика (favicon, manifest, robots.txt)
│   └─ index.html
├─ src/                         # Frontend Web App
│   ├─ assets/                  # Изображения, шрифты
│   ├─ components/              # UI-компоненты (кнопки, карточки)
│   ├─ hooks/                   # React hooks (useTelegram, useRealtime)
│   ├─ pages/                   # Страницы: Home, Lobby, Game, Profile, Leaderboard
│   ├─ services/                # API-клиенты: telegramSDK, PostgreSQL, tonConnect
│   ├─ utils/                   # Утилиты: timeSync, validators
│   ├─ App.tsx
│   ├─ main.tsx
│   └─ vite-env.d.ts
├─ backend/                     # Опционально: локальный backend для тестов
│   ├─ controllers/             # Логика маршрутов (rooms, users, payments)
│   ├─ models/                  # ORM/клиент  (типизация таблиц)
│   ├─ routes/                  # Express/Fastify роуты
│   ├─ utils/                   # JWT verify, HMAC, rate-limit
│   └─ index.ts                 # Точка входа сервера
├─ functions/                   # ( Edge Functions) для webhook, cron-job
│   └─ sendDailyLeaderboard.ts
├─ tonconnect-manifest.json     # Манифест для TON Connect
├─ .eslintrc.js                 # Конфиг ESLint
├─ .prettierrc                  # Конфиг Prettier
├─ tsconfig.json                # TypeScript config
├─ package.json                 # Скрипты и зависимости
.env
└─ README.md
*  
Вот краткий список основных таблиц  и их роли:
* users Хранит профиль: Telegram ID, имя, баланс Stars, флаг создания TON-кошелька. ↔ связана с wallets, participants, transactions, referrals. 
* wallets Содержит TON-адреса пользователей и дату создания. ↔ FK → users.id; используется для выплат. 
* rooms Описывает комнаты: тип (standard/bonus/hero), плата, макс. участников, статус. ↔ FK → users.id (creator); связана с participants, games. 
* participants Записывает, кто и когда зашёл в какую комнату. ↔ FK → rooms.id и users.id. 
* games Фиксирует каждый раунд: ссылка на room, время старта/конца, победитель. ↔ FK → rooms.id и users.id (winner); связана с taps. 
* taps Счётчики тапов каждого игрока в конкретной игре. ↔ FK → games.id и users.id. 
* transactions Логи движений средств: вход в игру, выплата, комиссия, реф-бонус. ↔ FK → users.id. 
* referrals Хранит реф-коды и владельцев, размер бонуса за первую игру. ↔ FK → users.id; связана с referral_uses. 
* referral_uses История активации реф-кодов: кто, чей код и когда использовал. ↔ code → referrals.code; FK → users.id. 
* bonus_progress Отслеживает прогресс в бонусной комнате: сколько тапов сделано, таймер, статус выполнения. ↔ FK → users.id. 
Взаимодействие: users ←→ wallets для выплат; users/rooms ←→ participants → games → taps для геймплея; transactions привязываются к users и отражают экономику; referrals ↔ referral_uses формируют систему бонусов; bonus_progress обеспечивает логику бонусной комнаты.
  Ниже кратко перечислены все необходимые таблицы и их поля для  (PostgreSQL):
1. users
* id UUID PRIMARY KEY 
* telegram_id BIGINT UNIQUE 
* username TEXT 
* balance_stars NUMERIC 
* has_ton_wallet BOOLEAN 
* created_at TIMESTAMP WITH TIME ZONE DEFAULT now() 
2. wallets
* id UUID PRIMARY KEY 
* user_id UUID REFERENCES users(id) ON DELETE CASCADE 
* ton_address TEXT UNIQUE 
* created_at TIMESTAMP WITH TIME ZONE DEFAULT now() 
3. rooms
* id UUID PRIMARY KEY 
* creator_id UUID REFERENCES users(id) 
* type TEXT CHECK(type IN ('standard','bonus','hero')) 
* entry_fee NUMERIC 
* max_players INT 
* status TEXT CHECK(status IN ('waiting','active','finished')) 
* created_at TIMESTAMP WITH TIME ZONE DEFAULT now() 
4. participants
* id UUID PRIMARY KEY 
* room_id UUID REFERENCES rooms(id) ON DELETE CASCADE 
* user_id UUID REFERENCES users(id) 
* joined_at TIMESTAMP WITH TIME ZONE DEFAULT now() 
5. games
* id UUID PRIMARY KEY 
* room_id UUID REFERENCES rooms(id) ON DELETE CASCADE 
* start_time TIMESTAMP WITH TIME ZONE 
* end_time TIMESTAMP WITH TIME ZONE 
* winner_id UUID REFERENCES users(id) 
6. taps
* id UUID PRIMARY KEY 
* game_id UUID REFERENCES games(id) ON DELETE CASCADE 
* user_id UUID REFERENCES users(id) 
* count INT 
* created_at TIMESTAMP WITH TIME ZONE DEFAULT now() 
7. transactions
* id UUID PRIMARY KEY 
* user_id UUID REFERENCES users(id) 
* amount NUMERIC 
* type TEXT CHECK(type IN ('entry','payout','fee','referral')) 
* description TEXT 
* created_at TIMESTAMP WITH TIME ZONE DEFAULT now() 
8. referrals
* code TEXT PRIMARY KEY 
* user_id UUID REFERENCES users(id) 
* bonus_amount NUMERIC 
* created_at TIMESTAMP WITH TIME ZONE DEFAULT now() 
9. referral_uses
* id UUID PRIMARY KEY 
* code TEXT REFERENCES referrals(code) 
* referred_user UUID REFERENCES users(id) 
* used_at TIMESTAMP WITH TIME ZONE DEFAULT now() 
10. bonus_progress
* id UUID PRIMARY KEY 
* user_id UUID REFERENCES users(id) 
* taps_so_far BIGINT DEFAULT 0 
* start_time TIMESTAMP WITH TIME ZONE 
* end_time TIMESTAMP WITH TIME ZONE 
* completed BOOLEAN DEFAULT FALSE 
   Подробный сценарий того, что видит и как ощущает пользователь на каждом шаге, и какой экран появляется в ответ на его действия. 1. Главный экран приложения Что видит пользователь: * В шапке справа : аватарка, имя , баланс Stars   * Основной блок: шесть карточек комнат с ценой входа (20, 80, 120, 250, 380, 500 Stars).  * Внизу меню-панель с иконками: Home, Leaderboard, Profile, Create Room.  Варианты действий: 1. Нажать на карточку комнаты (например, «20 Stars»). * Переход → окно ожидания выбранной комнаты если на счету достаточно stars если stars не достаточно Открывается платежный модал Telegram Stars.  2. Переключиться на «Leaderboard». * Появляется топ-10 игроков за 24 ч.  3. Перейти в «Profile». * Открывается профиль с балансом, историей игр и рефералами и кнопкой пополнить , Нажать «Пополнить». * Открывается платежный модал Telegram Stars.  4. Перейти в «Create Room». * Экран с двумя предложениями создания своей Hero-комнаты или вход в Hero комнату по уникальному ключу создателя   2. Окно ожидания и игровой экран одновременно Что видит пользователь: * Название и стоимость комнаты.  * Текущий счётчик участников (0…10) и аватарки по полукругу.  * Текст: «Ожидаем X из 10 игроков».  Действия и реакции: * Автоматически добавляется в список участников сразу после оплаты. Предварительного в комнату не должно быть пользователь входит в комнату только если у него списалась сумма за участие в этой комнате   * При достижении 10 участников начинается отсчёт 10…0, и начинается игра * Если пользователь покидает ожидание, он возвращается на главный экран без компенсации средств . 3. Игровой экран Что видит пользователь: * Вверху — синхронизированный таймер (60 сек).  * По краю — прогресс-бары всех участников с аватарками.  * В центре — большая кнопка «TAP».  Действие: * Каждый тап мгновенно увеличивает локальный счётчик.  * Каждые ~50 мс батч из новых тапов уходит на сервер.  * Сервер присылает обновлённые значения всем игрокам — прогресс-бары плавно подстраиваются.  По завершении: * Когда таймер заканчивается или кто-то набирает 200 тапов, появляется экран результатов. И победитель выводится в средину кнопки по верх кнопки   * Отображается победитель, призовой фонд .  * Кнопка «В лобби» или «Сыграть ещё» когда пользователь нажимает кнопку в лобби он переходит на главное меню когда пользователь нажимает на кнопку сыграть еще происходит автоподбор в другую свободную комнату если спустя 3 секунды комната не подобрана то создается новая .  4. Hero-комната (Create Room / Join Room) 4.1. Создание * Поля: «Max участников (до 10)» и «Fee (Stars)».  * Кнопка «Создать» → генерируется ключ комнаты.  * Переход в окно ожидания Hero-комнаты (аналогично стандартной).  4.2. Вход по ключу * Поле ввода ключа + кнопка «Войти».  * При вводе валидного ключа и оплате — переход в окно ожидания - игровой экран .  5. Бонусная комната Что видит пользователь: * Кнопка «Start Bonus».  * Прогресс-бар: 0 / 1 000 000 тапов.  * Таймер: 24 ч (от старта).  Действия: * Нажимает «Start Bonus» → таймер запускается.  * Тапает; каждый тап идёт в локальный счётчик и в батче на сервер.  * При достижении миллиона внутри 24 ч — выдаются 3000 Stars и возвращение на Home.  * Если время вышло — «Попробовать снова» возвращает к кнопке Start.  6. Leaderboard Что видит пользователь: * Список топ-10 игроков за последние 24 ч.  * Для каждого: аватар, имя, сумма выигрыша.  * Фильтры «Сегодня» / «Неделя» / «Все время» в шапке.  7. Профиль Что видит пользователь: * Баланс Stars и адрес TON-кошелька.  * Статистика: игр сыграно, выиграно  * Реферальная секция: * Код ссылки.  * Список рефералов с датой регистрации и суммой их взносов.  * Итого получено бонусов (20 + 1 за игру).  Итого Каждое действие пользователя мгновенно приводит к понятному экрану: от выбора комнаты до результатов игры. Таймеры и прогресс синхронизированы через WebSocket/Re­­altime, а client-side prediction обеспечивает почти нулевую задержку при тапах — игра чувствуется «живой» и отзывчивой на 100 %.    VITE_TELEGRAM_BOT_TOKEN=7898785686:AAH1vkZ6mVW2B0_mJ5ZVZDeKo34hG9IOj_Y

VITE_TELEGRAM_BOT_USERNAME=Chanceee_bot 

сделай прям полнй разбор всей системы и проанализируй полностью все , сделай глубокий анализ и сдела тех задание с деталями по каждому этапу
Хорошо, пользователь предоставил очень подробное техническое задание и хочет, чтобы я его дополнил, учтя все аспекты, включая инфраструктуру, базу данных, пользовательские сценарии и интеграции. Мне нужно провести глубокий анализ каждого раздела, убедившись, что ничего не упущено.

Первым делом, обращаю внимание на аутентификацию через Telegram. Важно проверить, как происходит регистрация и логин, особенно с учетом анонимных пользователей. Нужно убедиться, что данные из Telegram правильно переносятся в таблицы auth.users и public.users, и что транзакции выполняются атомарно. Также стоит уточнить, как обрабатываются ошибки при создании пользователя и как JWT токены связаны с telegram_id.

Далее, база данных. Пользователь предоставил структуру таблиц, но нужно проверить связи между ними, особенно внешние ключи и индексы для оптимизации запросов. Например, таблица participants ссылается на rooms и users, а taps связана с games и users. Важно убедиться, что RLS (Row-Level Security) правильно настроен для защиты данных пользователей.

Инфраструктура: использование Cloudflare Tunnel для фронтенда и бекенда. Нужно уточнить, как настроены туннели, как происходит балансировка нагрузки и обработка WebSocket-соединений. Также важно проверить настройки CI/CD в GitHub Actions, чтобы убедиться, что деплой происходит корректно.

Мониторинг и логирование: Prometheus для метрик, Loki/Grafana для логов. Нужно убедиться, что все необходимые метрики собираются (задержки API, частота сообщений WS), и что логи хранятся с правильным retention.

Интеграция с TON Connect: важно проверить процесс привязки кошелька, как обрабатываются транзакции, особенно неудачные. Также нужно убедиться, что баланс пользователя обновляется корректно после успешных транзакций.

Игровая логика: разделение на комнаты разных типов (Standard, Hero, Bonus). Нужно детально прописать сценарии для каждого типа, особенно для Hero-комнат, где организатор может запускать игру вручную. Важно учесть таймеры, обработку ничьих, возврат средств при истечении времени.

Пользовательский интерфейс: проверить все этапы, от главного экрана до профиля, убедиться, что переходы между экранами логичны, а элементы интерфейса (прогресс-бары, таймеры) синхронизированы через WebSocket. Особое внимание уделить анимациям и отклику на действия пользователя.

Безопасность: проверить валидацию входных данных, защиту от SQL-инъекций, частоту запросов. Убедиться, что JWT токены правильно валидируются и что RLS в PostgreSQL настроен корректно.

Тестирование: нужно предусмотреть тесты для каждого компонента — юнит-тесты для API, интеграционные тесты для проверки игровой логики, нагрузочное тестирование для WebSocket.

Документация: убедиться, что все endpoints задокументированы, есть примеры запросов и ответов. Также подготовить документацию по настройке окружения, деплою и мониторингу.

В итоге, нужно собрать всё в структурированное ТЗ, где каждый раздел детально описан, учтены все нюансы и потенциальные edge cases. Важно, чтобы разработчик мог взять этот документ и без дополнительных уточнений реализовать систему.

Полное техническое задание: Многопользовательская игровая платформа с комнатами (Standard, Hero, Bonus)
Версия 1.0

1. Архитектура системы
1.1. Компоненты
Frontend:

React + TypeScript + Vite:

SPA с HMR, роутингом через React Router.

Интеграция с Telegram Mini Apps SDK (telegram-web-app.js).

WebSocket-клиент для взаимодействия с игровыми комнатами.

Библиотеки:

@tonconnect/ui-react для интеграции TON Connect.

react-i18next для локализации (русский/английский).

Backend:

Node.js (Express):

REST API для аутентификации, управления комнатами, транзакциями.

WebSocket-сервер (ws) для реального взаимодействия в комнатах.

PostgreSQL:

Схемы: auth, public с RLS (Row-Level Security).

Репликация через Cloudflare D1 (опционально).

Инфраструктура:

Cloudflare Tunnel:

Фронтенд: cloudflared tunnel --url http://localhost:5173.

Бекенд: cloudflared tunnel --url http://localhost:3001.

CI/CD: GitHub Actions → деплой на Cloudflare Pages и сервер.

2. База данных (PostgreSQL)
2.1. Таблицы и связи
Таблица	Ключевые поля	RLS-политики
auth.users	id (UUID PK), telegram_id (BIGINT UNIQUE), balance_stars (NUMERIC), ...	Пользователь видит только свои данные.
public.rooms	id (UUID PK), creator_id (UUID), room_key (TEXT), entry_fee (NUMERIC)...	Организатор управляет своей комнатой.
participants	room_id (UUID), user_id (UUID), joined_at (TIMESTAMP)...	Участники видят только свои комнаты.
transactions	user_id (UUID), amount (NUMERIC), type (ENUM)...	Транзакции привязаны к пользователю.
bonus_progress	user_id (UUID), taps_so_far (BIGINT), end_time (TIMESTAMP)...	Прогресс бонуса доступен только владельцу.
2.2. SQL-функции
Генерация ключа комнаты:

sql
CREATE FUNCTION generate_room_key() RETURNS TEXT AS $$
BEGIN
  RETURN substr(md5(random()::text), 1, 6);
END;
$$ LANGUAGE plpgsql;
3. Аутентификация и безопасность
3.1. Flow регистрации
Пользователь открывает мини-приложение → Telegram передает telegram_id, username через webApp.initData.

POST /api/v1/user/init:

Если telegram_id отсутствует в auth.users:

Создается запись в public.users (UUID генерируется на клиенте).

Данные копируются в auth.users в транзакции.

JWT-токен:

Подписывается HMAC-SHA256 с секретом из process.env.JWT_SECRET.

Полезная нагрузка: { user_id: UUID, telegram_id: string }.

3.2. Защита данных
Row-Level Security (RLS):

sql
-- Для таблицы auth.users
CREATE POLICY user_policy ON auth.users
USING (id = current_setting('jwt.claims.user_id')::UUID);
4. Игровые комнаты
4.1. Типы комнат
Параметр	Standard	Hero	Bonus
Создание	Автоматический подбор	Организатор + ключ	Индивидуальный
Участники	До 10	До 30	1
Таймер	60 сек (игра)	10 мин (ожидание) + 30 сек	24 часа
Призовой фонд	90% победителю, 10% системе	90% победителю, 7% организатору	Фиксированный (3000 Stars)
4.2. Hero-комната: Детали
Создание:

Организатор вводит entry_fee → POST /api/v1/rooms → генерируется room_key.

Транзакция:

sql
BEGIN;
INSERT INTO rooms (...) VALUES (...);
INSERT INTO participants (room_id, user_id) VALUES (...);
COMMIT;
Присоединение:

Участник вводит room_key → проверка баланса → списание entry_fee.

Запуск игры:

Организатор нажимает "Начать" → PATCH /api/v1/rooms/{id}/start.

Сервер рассылает start_time через WebSocket.

5. Пользовательский интерфейс
5.1. Этапы взаимодействия
Этап	Экран	WebSocket-события
Главный экран	Карточки комнат, баланс, меню.	Нет
Ожидание игроков	Аватарки участников, таймер.	room_update (участники, статус).
Игра	Кнопка "TAP", прогресс-бары, таймер.	tap_progress (обновление счетчиков).
Результаты	Победитель, призовой фонд, кнопки действий.	game_end (финальные результаты).
5.2. Анимации
Предстартовый отсчет: CSS-анимация масштабирования текста ("3...2...1...TAP!").

Прогресс-бары: Плавное обновление через requestAnimationFrame.

6. Интеграция с TON
6.1. Привязка кошелька
Пользователь нажимает "Привязать кошелёк" → tonConnectUI.connect().

После подтверждения:

Обновление has_ton_wallet в auth.users.

Сохранение адреса в wallets.

6.2. Пополнение баланса
Telegram Stars:

js
window.Telegram.WebApp.openInvoice({...}, onSuccess, onError);
TON Transfer:

Генерация QR-кода через @tonconnect/sdk.

