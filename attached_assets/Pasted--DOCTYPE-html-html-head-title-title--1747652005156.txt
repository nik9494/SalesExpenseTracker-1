<!DOCTYPE html>
<html>
<head>
    <title>Кнопка с эффектом искр и прогрессивным разогревом</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* Глобальное отключение выделения на всей странице */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        
        html, body {
            overscroll-behavior: none; /* Предотвращает эффект "отскока" на iOS */
            overflow: hidden;
            touch-action: manipulation; /* Оптимизация для сенсорных устройств */
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            overflow: hidden;
        }
        
        .container {
            position: relative;
            width: 200px;
            height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .btn-class-name {
            --primary: 255, 90, 120;
            --secondary: 150, 50, 60;
            width: 80px;
            height: 70px;
            border: none;
            outline: none;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            touch-action: manipulation;
            outline: 10px solid rgb(var(--primary), .5);
            border-radius: 100%;
            position: relative;
            transition: .3s;
            z-index: 10;
        }
        
        .btn-class-name .back {
            background: rgb(var(--secondary));
            border-radius: 100%;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transition: background 0.5s;
            pointer-events: none; /* Предотвращает события мыши/тача */
        }
        
        .btn-class-name .front {
            background: linear-gradient(0deg, rgba(var(--primary), .6) 20%, rgba(var(--primary)) 50%);
            box-shadow: 0 .5em 1em -0.2em rgba(var(--secondary), .5);
            border-radius: 100%;
            position: absolute;
            border: 1px solid rgb(var(--secondary));
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 600;
            font-family: inherit;
            transform: translateY(-15%);
            transition: .15s;
            color: rgb(var(--secondary));
            pointer-events: none; /* Предотвращает события мыши/тача */
        }
        
        .btn-class-name:active .front {
            transform: translateY(0%);
            box-shadow: 0 0;
        }
        
        /* Стили для искр */
        .spark {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }
        
        /* Предотвращение залипания */
        .clicked {
            pointer-events: none;
        }
        
        /* Стили для разных уровней разогрева */
        .heat-level1 {
            box-shadow: 0 0 10px 4px rgba(255, 150, 120, 0.8);
        }
        
        .heat-level2 {
            box-shadow: 0 0 20px 8px rgba(255, 120, 80, 0.8);
        }
        
        .heat-level3 {
            box-shadow: 0 0 30px 12px rgba(255, 80, 40, 0.8);
        }
        
        /* Стили для уровней 2-4 */
        .heat-level1 .back {
            background: rgb(var(--secondary));
        }
        
        .heat-level2 .back {
            background: rgb(255, 140, 50);
        }
        
        .heat-level3 .back {
            background: rgb(255, 50, 50);
        }
        
        .heat-level1 .front {
            background: linear-gradient(0deg, rgba(var(--primary), .6) 20%, rgba(var(--primary)) 50%);
            color: rgb(var(--secondary));
        }
        
        .heat-level2 .front {
            background: linear-gradient(0deg, rgba(255, 140, 50, .6) 20%, rgba(255, 140, 50) 50%);
            color: rgb(180, 80, 30);
        }
        
        .heat-level3 .front {
            background: linear-gradient(0deg, rgba(255, 50, 50, .6) 20%, rgba(255, 50, 50) 50%);
            color: rgb(180, 30, 30);
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="btn-class-name">
            <span class="back"></span>
            <span class="front">TAP</span>
        </button>
    </div>
    
    <script>
        // После загрузки документа запускаем инициализацию кнопки
        document.addEventListener('DOMContentLoaded', function() {
            const button = document.querySelector('.btn-class-name');
            const container = document.querySelector('.container');
            
            // Глобальное предотвращение выделения текста
            document.addEventListener('selectstart', function(e) {
                e.preventDefault();
                return false;
            });
            
            // Предотвращение контекстного меню
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                return false;
            });
            
            // Переменные для отслеживания нажатий и уровней нагрева
            let heatLevel = 0;
            const MAX_HEAT_LEVEL = 3;
            const REQUIRED_CLICKS_FOR_LEVEL = [0, 10, 20, 30]; // Требуемое количество кликов для каждого уровня
            const EVALUATION_PERIOD = 3000; // Период времени для оценки (3 секунды)
            
            // Массив для хранения истории кликов
            let clickHistory = [];
            
            // Таймер для проверки падения интенсивности нажатий
            let cooldownTimer = null;
            
            // Количество искр для каждого уровня
            const SPARK_COUNTS = [0, 5, 8, 12];
            
            // Функция для создания искр
            function createSpark(x, y) {
                // Не создавать искры на уровне 0
                if (heatLevel === 0) return;
                
                const spark = document.createElement('div');
                spark.classList.add('spark');
                
                // Создаем SVG для искры
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                svg.setAttribute("width", "20");
                svg.setAttribute("height", "20");
                svg.setAttribute("viewBox", "0 0 20 20");
                
                // Разные цвета искр в зависимости от уровня нагрева
                let sparkColors;
                if (heatLevel === 1) {
                    sparkColors = [
                        "#ffdd00", // яркий желтый
                        "#ffbb00", // золотистый
                        "#ff9900"  // оранжевый
                    ];
                } else if (heatLevel === 2) {
                    sparkColors = [
                        "#ffbb00", // золотистый
                        "#ff9900", // оранжевый
                        "#ff7700", // темно-оранжевый
                        "#ff5500"  // оранжево-красный
                    ];
                } else {
                    sparkColors = [
                        "#ff9900", // оранжевый
                        "#ff7700", // темно-оранжевый
                        "#ff5500", // оранжево-красный
                        "#ff0000"  // красный
                    ];
                }
                
                // Случайный цвет из палитры
                const fillColor = sparkColors[Math.floor(Math.random() * sparkColors.length)];
                
                // Создаем форму искры - случайно выбираем между разными формами
                const sparkType = Math.floor(Math.random() * 3);
                
                if (sparkType === 0) {
                    // Линейная искра
                    const line = document.createElementNS(svgNS, "path");
                    const startX = 10;
                    const startY = 10;
                    const endX = 10 + (Math.random() * 6 - 3);
                    const endY = 10 + (Math.random() * 6 - 3);
                    const midX1 = startX + (Math.random() * 4 - 2);
                    const midY1 = startY + (Math.random() * 4 - 2);
                    const midX2 = endX + (Math.random() * 4 - 2);
                    const midY2 = endY + (Math.random() * 4 - 2);
                    
                    line.setAttribute("d", `M${startX},${startY} C${midX1},${midY1} ${midX2},${midY2} ${endX},${endY}`);
                    line.setAttribute("stroke", fillColor);
                    line.setAttribute("stroke-width", "2");
                    line.setAttribute("fill", "none");
                    svg.appendChild(line);
                } else if (sparkType === 1) {
                    // Звездообразная искра
                    const star = document.createElementNS(svgNS, "polygon");
                    const points = [];
                    const spikes = 4 + Math.floor(Math.random() * 3);
                    const outerRadius = 6 + Math.random() * 4;
                    const innerRadius = 2 + Math.random() * 3;
                    
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = Math.PI * i / spikes;
                        const pointX = 10 + Math.cos(angle) * radius;
                        const pointY = 10 + Math.sin(angle) * radius;
                        points.push(`${pointX},${pointY}`);
                    }
                    
                    star.setAttribute("points", points.join(" "));
                    star.setAttribute("fill", fillColor);
                    star.setAttribute("stroke", "rgba(255, 255, 255, 0.5)");
                    star.setAttribute("stroke-width", "0.5");
                    svg.appendChild(star);
                } else {
                    // Треугольная искра
                    const triangle = document.createElementNS(svgNS, "polygon");
                    const size = 3 + Math.random() * 5;
                    const angle = Math.random() * Math.PI * 2;
                    
                    const x1 = 10 + Math.cos(angle) * size;
                    const y1 = 10 + Math.sin(angle) * size;
                    const x2 = 10 + Math.cos(angle + 2.1) * size;
                    const y2 = 10 + Math.sin(angle + 2.1) * size;
                    const x3 = 10 + Math.cos(angle + 4.2) * size;
                    const y3 = 10 + Math.sin(angle + 4.2) * size;
                    
                    triangle.setAttribute("points", `${x1},${y1} ${x2},${y2} ${x3},${y3}`);
                    triangle.setAttribute("fill", fillColor);
                    svg.appendChild(triangle);
                }
                
                // Добавляем свечение для искр
                const glow = document.createElementNS(svgNS, "filter");
                glow.setAttribute("id", `glow-${Date.now()}-${Math.random()}`);
                
                const feGaussianBlur = document.createElementNS(svgNS, "feGaussianBlur");
                feGaussianBlur.setAttribute("stdDeviation", "1.5");
                feGaussianBlur.setAttribute("result", "blur");
                glow.appendChild(feGaussianBlur);
                
                const feMerge = document.createElementNS(svgNS, "feMerge");
                const feMergeNode1 = document.createElementNS(svgNS, "feMergeNode");
                feMergeNode1.setAttribute("in", "blur");
                const feMergeNode2 = document.createElementNS(svgNS, "feMergeNode");
                feMergeNode2.setAttribute("in", "SourceGraphic");
                
                feMerge.appendChild(feMergeNode1);
                feMerge.appendChild(feMergeNode2);
                glow.appendChild(feMerge);
                
                svg.appendChild(glow);
                
                if (sparkType !== 0) { // Не применяем к линейным искрам
                    svg.querySelector("polygon").setAttribute("filter", `url(#${glow.getAttribute("id")})`);
                }
                
                spark.appendChild(svg);
                
                // Начальная позиция искры
                spark.style.left = (x - 10) + 'px';
                spark.style.top = (y - 10) + 'px';
                
                document.body.appendChild(spark);
                
                // Анимация искры
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                const duration = 300 + Math.random() * 400;
                
                const endX = x + Math.cos(angle) * distance;
                const endY = y + Math.sin(angle) * distance;
                
                // Добавляем вращение к анимации для более реалистичного эффекта
                const rotateAmount = Math.random() * 720 - 360; // От -360 до 360 градусов
                
                spark.animate([
                    { 
                        transform: 'scale(1) rotate(0deg)', 
                        opacity: 1, 
                        left: (x - 10) + 'px', 
                        top: (y - 10) + 'px' 
                    },
                    { 
                        transform: `scale(${0.2 + Math.random() * 0.5}) rotate(${rotateAmount}deg)`, 
                        opacity: 0, 
                        left: (endX - 10) + 'px', 
                        top: (endY - 10) + 'px' 
                    }
                ], {
                    duration: duration,
                    easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)'
                });
                
                // Удаляем искру после анимации
                setTimeout(() => {
                    if (spark.parentNode) {
                        document.body.removeChild(spark);
                    }
                }, duration);
            }
            
            // Функция для определения уровня нагрева на основе интенсивности нажатий
            function updateHeatLevel() {
                const now = Date.now();
                
                // Очищаем старые клики, оставляя только те, что в периоде оценки
                clickHistory = clickHistory.filter(time => now - time < EVALUATION_PERIOD);
                
                // Количество кликов за период оценки
                const clickCount = clickHistory.length;
                
                // Определяем новый уровень нагрева
                let newLevel = 0;
                for (let i = MAX_HEAT_LEVEL; i > 0; i--) {
                    if (clickCount >= REQUIRED_CLICKS_FOR_LEVEL[i]) {
                        newLevel = i;
                        break;
                    }
                }
                
                // Если уровень изменился, обновляем стиль кнопки
                if (newLevel !== heatLevel) {
                    setHeatLevel(newLevel);
                }
                
                // Сбрасываем таймер охлаждения и запускаем новый
                clearTimeout(cooldownTimer);
                cooldownTimer = setTimeout(() => {
                    updateHeatLevel(); // Проверим снова после периода
                }, EVALUATION_PERIOD / 2); // Проверяем чаще, чем период оценки
            }
            
            // Функция для установки уровня перегрева
            function setHeatLevel(level) {
                // Проверяем, изменился ли уровень и находится ли в диапазоне
                if (heatLevel === level || level < 0 || level > MAX_HEAT_LEVEL) return;
                
                // Сначала убираем все классы перегрева
                button.classList.remove('heat-level1', 'heat-level2', 'heat-level3');
                
                // Добавляем соответствующие классы для текущего уровня перегрева
                if (level >= 1) {
                    button.classList.add('heat-level' + level);
                }
                
                // Сохраняем текущий уровень
                heatLevel = level;
            }
            
            // Функция для создания эффекта фейерверка
            function createFirework(x, y) {
                // Количество искр в зависимости от уровня нагрева
                const sparkCount = SPARK_COUNTS[heatLevel];
                
                for (let i = 0; i < sparkCount; i++) {
                    setTimeout(() => {
                        createSpark(x, y);
                    }, Math.random() * 100); // Небольшая случайная задержка для более естественного эффекта
                }
            }
            
            // Обработчик клика на кнопку
            function handleButtonInteraction(e) {
                // Предотвращаем все стандартные действия браузера
                e.preventDefault();
                e.stopPropagation();
                
                // Добавляем текущий клик в историю
                clickHistory.push(Date.now());
                
                // Обновляем уровень нагрева
                updateHeatLevel();
                
                // Создаем искры при каждом нажатии
                const updatedRect = button.getBoundingClientRect();
                const centerX = updatedRect.left + updatedRect.width / 2;
                const centerY = updatedRect.top + updatedRect.height / 2;
                
                // Создаем фейерверк из искр
                createFirework(centerX, centerY);
                
                return false;
            }
            
            // Назначаем обработчики в едином формате для всех событий
            // Клики мыши
            button.addEventListener('mousedown', function(e) {
                e.preventDefault();
                button.classList.add('clicked');
                handleButtonInteraction(e);
            }, { passive: false });
            
            button.addEventListener('mouseleave', function(e) {
                e.preventDefault();
                button.classList.remove('clicked');
            }, { passive: false });
            
            button.addEventListener('mouseup', function(e) {
                e.preventDefault();
                button.classList.remove('clicked');
            }, { passive: false });
            
            // Сенсорные события
            button.addEventListener('touchstart', function(e) {
                e.preventDefault();
                button.classList.add('clicked');
                handleButtonInteraction(e);
            }, { passive: false });
            
            button.addEventListener('touchend', function(e) {
                e.preventDefault();
                button.classList.remove('clicked');
            }, { passive: false });
            
            button.addEventListener('touchcancel', function(e) {
                e.preventDefault();
                button.classList.remove('clicked');
            }, { passive: false });
            
            // Предотвращаем масштабирование двойным тапом
            let lastTapTime = 0;
            document.addEventListener('touchend', function(e) {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTapTime;
                if (tapLength < 500 && tapLength > 0) {
                    e.preventDefault();
                }
                lastTapTime = currentTime;
            }, { passive: false });
        });
    </script>
</body>
</html>